<mxfile host="Electron" agent="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) draw.io/27.0.9 Chrome/134.0.6998.205 Electron/35.5.1 Safari/537.36" version="27.0.9">
  <diagram name="Page-1" id="XTeMT3vIgP22Tn7XUE1S">
    <mxGraphModel dx="1339" dy="1992" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="-FfBsdi4UKGn_Bai_2C5-1" value="&lt;h1 style=&quot;margin-top: 0px;&quot;&gt;Heading&lt;/h1&gt;&lt;p&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/p&gt;&lt;p&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/p&gt;&lt;p&gt;#include &amp;lt;string.h&amp;gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;#define MAX_VERTICES 100&lt;/p&gt;&lt;p&gt;#define MAX_EDGES 100&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;int n_vertices_global;&lt;/p&gt;&lt;p&gt;int n_edges_global;&lt;/p&gt;&lt;p&gt;int inc_mat_global[MAX_VERTICES][MAX_EDGES];&lt;/p&gt;&lt;p&gt;int adj_global[MAX_VERTICES][MAX_VERTICES];&lt;/p&gt;&lt;p&gt;int reach_global[MAX_VERTICES][MAX_VERTICES];&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;void read_incidence_matrix_simplified(const char *filename) {&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; FILE *fin = fopen(filename, &quot;r&quot;);&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; int row = 0;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; char line[MAX_EDGES * 5]; // Assuming each number is up to 4 digits + space&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; while (fgets(line, sizeof(line), fin) != NULL) {&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; char *token = strtok(line, &quot; \n&quot;);&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; int col = 0;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; while (token != NULL) {&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; inc_mat_global[row][col] = atoi(token);&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; token = strtok(NULL, &quot; \n&quot;);&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; col++;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; n_edges_global = col; // Assuming all rows have the same number of edges&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; row++;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; }&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; n_vertices_global = row;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; fclose(fin);&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;// Simplified incidence2adjacency&lt;/p&gt;&lt;p&gt;void incidence2adjacency_simplified() {&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; // Initialize adjacency matrix to 0&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; for (int i = 0; i &amp;lt; n_vertices_global; ++i) {&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for (int j = 0; j &amp;lt; n_vertices_global; ++j) {&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; adj_global[i][j] = 0;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; }&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; for (int j = 0; j &amp;lt; n_edges_global; ++j) {&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; int src = -1, dst = -1;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for (int i = 0; i &amp;lt; n_vertices_global; ++i) {&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (inc_mat_global[i][j] == -1) {&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; src = i;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; } else if (inc_mat_global[i][j] == 1) {&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; dst = i;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; // Assuming valid src and dst for simplicity as per request&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; adj_global[src][dst] = 1;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; }&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;// Simplified compute_reachability (Floyd-Warshall variant)&lt;/p&gt;&lt;p&gt;void compute_reachability_simplified() {&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; // Initialize reachability matrix&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; for (int i = 0; i &amp;lt; n_vertices_global; ++i) {&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for (int j = 0; j &amp;lt; n_vertices_global; ++j) {&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; reach_global[i][j] = adj_global[i][j];&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; reach_global[i][i] = 1; // A vertex is reachable from itself&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; }&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; for (int k = 0; k &amp;lt; n_vertices_global; ++k) {&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for (int i = 0; i &amp;lt; n_vertices_global; ++i) {&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (!reach_global[i][k]) continue; // Optimization&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for (int j = 0; j &amp;lt; n_vertices_global; ++j) {&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (reach_global[k][j]) {&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; reach_global[i][j] = 1;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; }&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;// Simplified is_one_way_connected&lt;/p&gt;&lt;p&gt;int is_one_way_connected_simplified() {&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; for (int i = 0; i &amp;lt; n_vertices_global; ++i) {&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for (int j = i + 1; j &amp;lt; n_vertices_global; ++j) {&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; if (!reach_global[i][j] &amp;amp;&amp;amp; !reach_global[j][i]) {&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; return 0; // Not one-way connected&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; }&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; return 1; // One-way connected&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;// Simplified print_matrix&lt;/p&gt;&lt;p&gt;void print_matrix_simplified(const char *title, int n, int matrix[MAX_VERTICES][MAX_VERTICES]) {&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; printf(&quot;%s (%d×%d):\n&quot;, title, n, n);&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; for (int i = 0; i &amp;lt; n; ++i) {&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; for (int j = 0; j &amp;lt; n; ++j) {&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; printf(&quot;%d &quot;, matrix[i][j]);&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; }&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; printf(&quot;\n&quot;);&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; }&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; printf(&quot;\n&quot;);&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;int main() {&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; // Input file is hardcoded as &quot;input.txt&quot; in the original C++ code&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; read_incidence_matrix_simplified(&quot;input.txt&quot;);&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; incidence2adjacency_simplified();&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; print_matrix_simplified(&quot;Матрица смежности&quot;, n_vertices_global, adj_global);&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; compute_reachability_simplified();&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; print_matrix_simplified(&quot;Матрица достижимости&quot;, n_vertices_global, reach_global);&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; if (is_one_way_connected_simplified()) {&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; printf(&quot;Граф является односторонне связным.\n&quot;);&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; } else {&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; printf(&quot;Граф НЕ является односторонне связным.\n&quot;);&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; }&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp; &amp;nbsp; return 0;&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;" style="text;html=1;whiteSpace=wrap;overflow=hidden;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="500" y="-760" width="530" height="1910" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
